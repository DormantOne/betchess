<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0" />
  <title>BetChess â€” 3 Offers, Bankroll, Stockfish</title>

  <!-- chessboard.js CSS -->
  <link rel="stylesheet" href="https://unpkg.com/@chrisoakman/chessboardjs@1.0.0/dist/chessboard-1.0.0.min.css">

  <!-- Google Font for distinctive typography -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700;800&family=Outfit:wght@400;600;800;900&display=swap" rel="stylesheet">

  <style>
    :root {
      --bg: #0a0c10;
      --panel: #12151c;
      --panel-glass: rgba(18, 21, 28, 0.92);
      --muted: #6b7a90;
      --text: #e2e6ed;
      --accent: #f5a623;
      --accent-dim: rgba(245, 166, 35, 0.12);
      --good: #34d399;
      --good-dim: rgba(52, 211, 153, 0.12);
      --bad: #f87171;
      --bad-dim: rgba(248, 113, 113, 0.12);
      --border: #1e2533;
      --border-light: #2a3345;
      --glow: rgba(245, 166, 35, 0.08);
    }

    * { box-sizing: border-box; margin: 0; padding: 0; }

    body {
      background: var(--bg);
      color: var(--text);
      font-family: 'Outfit', system-ui, -apple-system, sans-serif;
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 20px;
      /* Subtle animated grain texture */
      position: relative;
    }

    body::before {
      content: '';
      position: fixed;
      inset: 0;
      background:
        radial-gradient(ellipse at 20% 50%, rgba(245,166,35,0.03) 0%, transparent 60%),
        radial-gradient(ellipse at 80% 20%, rgba(52,211,153,0.02) 0%, transparent 50%),
        radial-gradient(ellipse at 50% 90%, rgba(99,102,241,0.02) 0%, transparent 50%);
      pointer-events: none;
      z-index: 0;
    }

    .wrap {
      position: relative;
      z-index: 1;
      width: min(1140px, 100%);
      display: grid;
      gap: 18px;
      grid-template-columns: 480px 1fr;
    }
    @media (max-width: 1000px) {
      .wrap { grid-template-columns: 1fr; max-width: 520px; }
    }

    /* â”€â”€ Cards â”€â”€ */
    .card {
      background: var(--panel-glass);
      border: 1px solid var(--border);
      border-radius: 16px;
      overflow: hidden;
      backdrop-filter: blur(12px);
      box-shadow:
        0 1px 0 rgba(255,255,255,0.03) inset,
        0 24px 60px rgba(0,0,0,0.4);
    }

    .head {
      padding: 16px 20px;
      border-bottom: 1px solid var(--border);
      display: flex;
      align-items: baseline;
      justify-content: space-between;
      gap: 12px;
    }
    .title {
      font-weight: 900;
      font-size: 1.15rem;
      letter-spacing: -0.3px;
    }
    .title .icon { margin-right: 6px; }
    .sub {
      color: var(--muted);
      font-size: 0.82rem;
      line-height: 1.4;
      max-width: 340px;
    }
    .body { padding: 16px 20px; }

    /* â”€â”€ Board â”€â”€ */
    #board {
      width: 100%;
      max-width: 480px;
      margin: 0 auto;
    }

    /* â”€â”€ Status row â”€â”€ */
    .row {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      align-items: center;
    }
    .pill {
      border: 1px solid var(--border);
      padding: 6px 12px;
      border-radius: 999px;
      color: var(--muted);
      font-size: 0.82rem;
      background: rgba(0,0,0,0.2);
      white-space: nowrap;
    }
    .pill strong {
      color: var(--text);
      font-family: 'JetBrains Mono', monospace;
      font-weight: 700;
    }
    .pill.good { border-color: rgba(52,211,153,0.2); background: var(--good-dim); }
    .pill.good strong { color: var(--good); }
    .pill.bad { border-color: rgba(248,113,113,0.2); background: var(--bad-dim); }
    .pill.bad strong { color: var(--bad); }

    /* â”€â”€ Bankroll bar â”€â”€ */
    .bankroll-bar {
      margin-top: 12px;
      height: 6px;
      background: rgba(255,255,255,0.04);
      border-radius: 99px;
      overflow: hidden;
      border: 1px solid var(--border);
    }
    .bankroll-fill {
      height: 100%;
      background: linear-gradient(90deg, var(--good), var(--accent));
      border-radius: 99px;
      transition: width 0.4s cubic-bezier(0.22, 1, 0.36, 1);
    }

    /* â”€â”€ Buttons â”€â”€ */
    button {
      font-family: 'Outfit', sans-serif;
      background: rgba(255,255,255,0.03);
      color: var(--text);
      border: 1px solid var(--border-light);
      border-radius: 10px;
      padding: 9px 14px;
      cursor: pointer;
      font-weight: 700;
      font-size: 0.85rem;
      letter-spacing: 0.2px;
      transition: all 0.15s ease;
    }
    button:hover {
      background: rgba(255,255,255,0.06);
      border-color: #3a4a5f;
    }
    button:active { transform: translateY(1px); }
    button.primary {
      border-color: rgba(245,166,35,0.4);
      background: var(--accent-dim);
      color: var(--accent);
    }
    button.primary:hover {
      background: rgba(245,166,35,0.18);
    }
    button.danger {
      border-color: rgba(248,113,113,0.3);
      color: var(--bad);
    }
    button.danger:hover {
      background: var(--bad-dim);
    }
    button:disabled {
      opacity: 0.4;
      cursor: not-allowed;
      transform: none !important;
    }

    /* â”€â”€ Offers â”€â”€ */
    .offers { display: grid; gap: 8px; margin-top: 14px; }
    .offer {
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 12px 14px;
      display: flex;
      justify-content: space-between;
      gap: 10px;
      align-items: center;
      background: rgba(0,0,0,0.15);
      transition: border-color 0.2s ease, background 0.2s ease;
    }
    .offer:hover {
      border-color: var(--border-light);
      background: rgba(0,0,0,0.25);
    }
    .offer .left { display: flex; flex-direction: column; gap: 3px; }
    .offer .move {
      font-weight: 900;
      font-size: 1rem;
      letter-spacing: -0.2px;
    }
    .offer .meta {
      color: var(--muted);
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.78rem;
    }
    .offer .right {
      display: flex;
      gap: 10px;
      align-items: center;
    }
    .offer .cost {
      font-weight: 800;
      color: var(--accent);
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.92rem;
    }

    /* Rank badges for offers */
    .rank-badge {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 24px;
      height: 24px;
      border-radius: 6px;
      font-weight: 900;
      font-size: 0.75rem;
      margin-right: 8px;
      flex-shrink: 0;
    }
    .rank-1 { background: rgba(245,166,35,0.15); color: var(--accent); border: 1px solid rgba(245,166,35,0.3); }
    .rank-2 { background: rgba(148,163,184,0.1); color: #94a3b8; border: 1px solid rgba(148,163,184,0.2); }
    .rank-3 { background: rgba(100,116,139,0.08); color: #64748b; border: 1px solid rgba(100,116,139,0.15); }

    /* â”€â”€ Log â”€â”€ */
    .log {
      margin-top: 14px;
      background: rgba(0,0,0,0.3);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 12px;
      color: #8899aa;
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.78rem;
      line-height: 1.5;
      white-space: pre-wrap;
      max-height: 220px;
      overflow-y: auto;
    }
    .log::-webkit-scrollbar { width: 4px; }
    .log::-webkit-scrollbar-track { background: transparent; }
    .log::-webkit-scrollbar-thumb { background: var(--border-light); border-radius: 99px; }

    /* â”€â”€ Loading spinner â”€â”€ */
    .spinner {
      display: inline-block;
      width: 14px; height: 14px;
      border: 2px solid var(--border-light);
      border-top-color: var(--accent);
      border-radius: 50%;
      animation: spin 0.7s linear infinite;
      vertical-align: middle;
      margin-right: 6px;
    }
    @keyframes spin { to { transform: rotate(360deg); } }

    /* â”€â”€ Move number counter â”€â”€ */
    .move-counter {
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.78rem;
      color: var(--muted);
      margin-top: 8px;
    }
  </style>
</head>
<body>
  <div class="wrap">

    <!-- Left: Board -->
    <div class="card">
      <div class="head">
        <div>
          <div class="title"><span class="icon">â™Ÿ</span>BetChess</div>
          <div class="sub">Pick from 3 Stockfish offers each turn. Best costs more. Go bankrupt = lose. Deliver mate = win.</div>
        </div>
      </div>
      <div class="body">
        <div id="board"></div>
        <div class="move-counter" id="moveCounter"></div>
      </div>
    </div>

    <!-- Right: Controls -->
    <div class="card">
      <div class="head">
        <div>
          <div class="title">Control Panel</div>
          <div class="sub">You play White Â· Stockfish plays Black</div>
        </div>
      </div>
      <div class="body">

        <!-- Status pills -->
        <div class="row">
          <div class="pill"><span>Turn:</span> <strong id="turn">â€”</strong></div>
          <div class="pill good"><span>Bank:</span> <strong id="bank">$â€”</strong></div>
          <div class="pill"><span>Status:</span> <strong id="status">Loadingâ€¦</strong></div>
        </div>

        <!-- Bankroll bar -->
        <div class="bankroll-bar">
          <div class="bankroll-fill" id="bankFill" style="width:100%"></div>
        </div>

        <!-- Action buttons -->
        <div class="row" style="margin-top:14px">
          <button class="primary" id="newGame">New Game</button>
          <button id="refreshOffers">Re-roll Offers</button>
          <button class="danger" id="resign">Resign</button>
        </div>

        <!-- 3 Offers rendered here -->
        <div class="offers" id="offers"></div>

        <!-- Event log -->
        <div class="log" id="log"></div>
      </div>
    </div>

  </div>

  <!-- â•â•â•â•â•â•â•â•â•â•â• Dependencies â•â•â•â•â•â•â•â•â•â•â• -->
  <script src="https://unpkg.com/jquery@3.5.1/dist/jquery.min.js"></script>
  <script src="https://unpkg.com/@chrisoakman/chessboardjs@1.0.0/dist/chessboard-1.0.0.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.10.3/chess.min.js"></script>

  <script>
  (function () {
    'use strict';

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    //  CONFIG
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    //
    //  KEY FIX: Use the pure-JS (asm.js) stockfish build from
    //  stockfish.js@10.0.2 on jsdelivr. The WASM build fails in
    //  blob-origin workers because the .wasm binary fetch gets
    //  blocked by same-origin policy (blob: â‰  cdn origin).
    //
    //  The asm.js version is a single JS file â€” no sidecar binary â€”
    //  so importScripts() inside a blob worker "just works".
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    const STOCKFISH_JS_URL =
      'https://cdn.jsdelivr.net/npm/stockfish.js@10.0.2/stockfish.js';

    const PIECE_THEME =
      'https://unpkg.com/@chrisoakman/chessboardjs@1.0.0/dist/img/chesspieces/wikipedia/{piece}.png';

    const STARTING_BANKROLL = 25;
    const DEPTH_OFFERS      = 12;   // MultiPV analysis depth for the 3 offers
    const DEPTH_ENGINE       = 12;   // Engine's own-move search depth

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    //  UI REFERENCES
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    const elTurn    = document.getElementById('turn');
    const elBank    = document.getElementById('bank');
    const elStatus  = document.getElementById('status');
    const elOffers  = document.getElementById('offers');
    const elLog     = document.getElementById('log');
    const elBankFill = document.getElementById('bankFill');
    const elMoveCtr = document.getElementById('moveCounter');

    function log(s) {
      elLog.textContent = (elLog.textContent ? elLog.textContent + '\n' : '') + s;
      elLog.scrollTop = elLog.scrollHeight;
    }
    function setStatus(s) { elStatus.textContent = s; }
    function money(n) { return '$' + Math.max(0, n).toLocaleString(undefined, { maximumFractionDigits: 0 }); }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    //  GAME STATE
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    let game     = new Chess();
    let board    = null;
    let bankroll = STARTING_BANKROLL;
    let moveNum  = 0;    // counts white moves played
    let locked   = false; // prevents double-clicks during async ops

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    //  STOCKFISH ENGINE WRAPPER (UCI over Web Worker)
    //
    //  Creates a blob worker that importScripts the asm.js build.
    //  All analysis calls are serialized through a queue so
    //  MultiPV output from concurrent calls never interleaves.
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    class UCIEngine {
      constructor() {
        this.worker     = null;
        this._listeners = [];
        this._queue     = Promise.resolve();
      }

      async init() {
        // Build a blob worker that pulls in stockfish.js via importScripts.
        // blob: origin counts as same-origin, sidestepping CORS issues.
        const code = `importScripts(${JSON.stringify(STOCKFISH_JS_URL)});`;
        const blob = new Blob([code], { type: 'application/javascript' });
        const url  = URL.createObjectURL(blob);
        this.worker = new Worker(url);

        // Fan out every message from the worker to all active listeners.
        this.worker.onmessage = (e) => {
          const line = String(e.data || '').trim();
          if (!line) return;
          this._listeners.forEach(fn => fn(line));
        };

        this.worker.onerror = (err) => {
          log('WORKER ERROR: ' + (err.message || err));
        };

        // UCI handshake
        await this._waitFor('uciok',   () => this.send('uci'),     10000);
        await this._waitFor('readyok', () => this.send('isready'),  10000);
        this.send('ucinewgame');
        await this._waitFor('readyok', () => this.send('isready'),  10000);
      }

      send(cmd) {
        this.worker.postMessage(cmd);
      }

      // Wait for a specific token from engine output, with timeout.
      _waitFor(token, kickFn, timeoutMs) {
        return new Promise((resolve, reject) => {
          let done = false;
          const timer = setTimeout(() => {
            if (done) return;
            done = true;
            this._listeners = this._listeners.filter(x => x !== onLine);
            reject(new Error('Timeout waiting for: ' + token));
          }, timeoutMs);

          const onLine = (line) => {
            if (line === token || line.includes(token)) {
              if (done) return;
              done = true;
              clearTimeout(timer);
              this._listeners = this._listeners.filter(x => x !== onLine);
              resolve();
            }
          };

          this._listeners.push(onLine);
          kickFn();
        });
      }

      // Public: serialized analysis (returns promise of array of PV results).
      analyze(fen, multipv, depth) {
        this._queue = this._queue.then(() => this._analyzeOnce(fen, multipv, depth));
        return this._queue;
      }

      // Internal: single analysis run.
      _analyzeOnce(fen, multipv, depth) {
        return new Promise((resolve, reject) => {
          const linesByPv = new Map(); // pvIndex -> { uci, scoreText, cp, mate }
          let finished = false;

          const timeout = setTimeout(() => {
            cleanup();
            reject(new Error('Engine analysis timeout'));
          }, 15000);

          const onLine = (line) => {
            // Parse "info" lines for score + principal variation
            if (line.startsWith('info ')) {
              const mp = /(?:^|\s)multipv\s+(\d+)/.exec(line);
              const pv = /(?:^|\s)pv\s+([a-h][1-8][a-h][1-8][qrbn]?)/.exec(line);
              if (!pv) return;

              const idx = mp ? parseInt(mp[1], 10) : 1;

              let cp = null, mate = null, scoreText = '';
              const mCp   = /(?:^|\s)score\s+cp\s+(-?\d+)/.exec(line);
              const mMate = /(?:^|\s)score\s+mate\s+(-?\d+)/.exec(line);
              if (mMate) {
                mate = parseInt(mMate[1], 10);
                scoreText = (mate > 0 ? '#+' : '#') + mate;
              } else if (mCp) {
                cp = parseInt(mCp[1], 10);
                scoreText = (cp >= 0 ? '+' : '') + (cp / 100).toFixed(2);
              }

              linesByPv.set(idx, { uci: pv[1], cp, mate, scoreText });
            }

            // "bestmove" signals analysis is complete.
            if (line.startsWith('bestmove ')) {
              if (finished) return;
              finished = true;
              cleanup();
              const out = [];
              for (let i = 1; i <= multipv; i++) {
                if (linesByPv.has(i)) out.push({ pv: i, ...linesByPv.get(i) });
              }
              resolve(out);
            }
          };

          const cleanup = () => {
            clearTimeout(timeout);
            this._listeners = this._listeners.filter(x => x !== onLine);
            try { this.send('stop'); } catch (_) {}
          };

          this._listeners.push(onLine);

          // Configure MultiPV and start search
          this.send('setoption name MultiPV value ' + multipv);
          this.send('position fen ' + fen);
          this.send('go depth ' + depth);
        });
      }
    }

    const engine = new UCIEngine();

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    //  MOVE HELPERS
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    // Convert UCI string (e.g. "e2e4") to chess.js move object.
    function uciToMoveObj(uci) {
      const from = uci.slice(0, 2);
      const to   = uci.slice(2, 4);
      const promo = uci.length > 4 ? uci[4] : undefined;
      return promo ? { from, to, promotion: promo } : { from, to };
    }

    // Convert UCI string to SAN notation using current position.
    function uciToSAN(uci) {
      const tmp = new Chess(game.fen());
      const m = tmp.move(uciToMoveObj(uci));
      return m ? m.san : uci;
    }

    // Check all game-over conditions.
    function isGameOver() {
      if (game.in_checkmate())
        return { over: true, msg: (game.turn() === 'w' ? 'Black' : 'White') + ' wins by checkmate!' };
      if (game.in_stalemate())
        return { over: true, msg: 'Stalemate â€” draw.' };
      if (game.in_threefold_repetition())
        return { over: true, msg: 'Threefold repetition â€” draw.' };
      if (game.insufficient_material())
        return { over: true, msg: 'Insufficient material â€” draw.' };
      if (game.in_draw())
        return { over: true, msg: 'Draw.' };
      return { over: false, msg: '' };
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    //  UI SYNC
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    function syncUI() {
      elTurn.textContent = (game.turn() === 'w') ? 'White (you)' : 'Black (SF)';
      elBank.textContent = money(bankroll);

      // Bankroll bar (percentage of starting bankroll)
      const pct = Math.max(0, Math.min(100, (bankroll / STARTING_BANKROLL) * 100));
      elBankFill.style.width = pct + '%';

      // Color the bank pill based on health
      const bankPill = elBank.closest('.pill');
      if (bankPill) {
        bankPill.className = 'pill ' + (bankroll > 8 ? 'good' : bankroll > 3 ? '' : 'bad');
      }

      // Move counter
      elMoveCtr.textContent = moveNum > 0 ? `Move ${moveNum} Â· ${game.fen().split(' ').pop()} full moves` : '';

      const over = isGameOver();
      if (over.over) { setStatus(over.msg); return; }
      if (bankroll <= 0) { setStatus('ğŸ’€ Bankrupt â€” you lose!'); return; }
      setStatus(game.turn() === 'w' ? 'Choose a move offer â†“' : 'Stockfish thinkingâ€¦');
    }

    function syncBoard() {
      board.position(game.fen(), true);
      syncUI();
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    //  OFFER SYSTEM
    //
    //  Each turn, Stockfish analyzes MultiPV=3 at DEPTH_OFFERS.
    //  The 3 candidate moves are priced:
    //    Rank 1 (best)  â†’ $3
    //    Rank 2 (good)  â†’ $2
    //    Rank 3 (okay)  â†’ $1
    //
    //  If fewer than 3 PVs come back (e.g. only 2 legal moves),
    //  we pad with remaining legal moves at $1.
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    async function buildOffersForWhite() {
      if (game.turn() !== 'w' || bankroll <= 0) return;

      elOffers.innerHTML = '';
      setStatus('Analyzing 3 offersâ€¦');
      log(`â”€â”€ Move ${moveNum + 1}: analyzing (MultiPV=3, depth=${DEPTH_OFFERS})â€¦`);

      let offers;
      try {
        offers = await engine.analyze(game.fen(), 3, DEPTH_OFFERS);
      } catch (err) {
        setStatus('Engine error â€” see log.');
        log('ENGINE ERROR: ' + (err && err.message ? err.message : String(err)));
        return;
      }

      // Pad to 3 if engine returned fewer (happens when â‰¤2 legal moves)
      const legals = game.moves({ verbose: true }).map(m => m.from + m.to + (m.promotion || ''));
      const seen = new Set(offers.map(o => o.uci));
      for (const u of legals) {
        if (offers.length >= 3) break;
        if (!seen.has(u)) {
          offers.push({ pv: offers.length + 1, uci: u, cp: null, mate: null, scoreText: '?' });
          seen.add(u);
        }
      }
      offers = offers.slice(0, 3);

      // Attach cost and SAN to each offer
      const priced = offers.map((o, idx) => ({
        ...o,
        cost: 3 - idx,                    // best=$3, mid=$2, budget=$1
        san: uciToSAN(o.uci),
      }));

      renderOffers(priced);
      setStatus('Pick one (best costs more) â†“');
      log('3 offers ready.');
    }

    function renderOffers(offers) {
      elOffers.innerHTML = '';
      offers.forEach((o, idx) => {
        const canAfford = bankroll >= o.cost;
        const row = document.createElement('div');
        row.className = 'offer';

        // Left side: rank badge + move + eval
        const left = document.createElement('div');
        left.className = 'left';
        left.style.display = 'flex';
        left.style.flexDirection = 'row';
        left.style.alignItems = 'center';
        left.style.gap = '10px';

        const badge = document.createElement('span');
        badge.className = 'rank-badge rank-' + (idx + 1);
        badge.textContent = idx + 1;

        const info = document.createElement('div');
        const moveLine = document.createElement('div');
        moveLine.className = 'move';
        moveLine.textContent = o.san;
        const metaLine = document.createElement('div');
        metaLine.className = 'meta';
        metaLine.textContent = `eval ${o.scoreText || 'â€”'}`;

        info.appendChild(moveLine);
        info.appendChild(metaLine);
        left.appendChild(badge);
        left.appendChild(info);

        // Right side: cost + play button
        const right = document.createElement('div');
        right.className = 'right';

        const cost = document.createElement('div');
        cost.className = 'cost';
        cost.textContent = `$${o.cost}`;

        const btn = document.createElement('button');
        btn.textContent = canAfford ? 'Play' : 'Broke';
        btn.disabled = !canAfford;
        if (canAfford) {
          btn.className = 'primary';
        }
        btn.onclick = () => playWhiteOffer(o);

        right.appendChild(cost);
        right.appendChild(btn);

        row.appendChild(left);
        row.appendChild(right);
        elOffers.appendChild(row);
      });
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    //  PLAY MOVES
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    async function playWhiteOffer(offer) {
      if (locked || game.turn() !== 'w' || bankroll < offer.cost) return;
      locked = true;

      bankroll -= offer.cost;
      moveNum++;
      log(`WHITE ${moveNum}. ${offer.san}  (âˆ’$${offer.cost}, bank=${money(bankroll)})`);

      const m = game.move(uciToMoveObj(offer.uci));
      if (!m) {
        log('!! Illegal move from offer: ' + offer.uci);
        setStatus('Illegal offer move â€” see log.');
        locked = false;
        return;
      }

      elOffers.innerHTML = '';
      syncBoard();

      // Check end conditions after white's move
      if (bankroll <= 0) {
        setStatus('ğŸ’€ Bankrupt â€” you lose!');
        log('BANKRUPT.');
        locked = false;
        return;
      }
      const over = isGameOver();
      if (over.over) {
        setStatus(over.msg);
        log('GAME OVER: ' + over.msg);
        locked = false;
        return;
      }

      // Black responds
      await playBlackBestMove();
      locked = false;
    }

    async function playBlackBestMove() {
      if (game.turn() !== 'b') return;

      setStatus('Stockfish thinkingâ€¦');
      log('BLACK thinkingâ€¦');

      let lines;
      try {
        lines = await engine.analyze(game.fen(), 1, DEPTH_ENGINE);
      } catch (err) {
        setStatus('Engine error on black move â€” see log.');
        log('ENGINE ERROR: ' + (err && err.message ? err.message : String(err)));
        return;
      }

      const best = lines && lines[0] ? lines[0].uci : null;
      if (!best) {
        setStatus('No engine move received.');
        log('!! No best move received from engine.');
        return;
      }

      // Convert to SAN before applying
      const san = (() => {
        const tmp = new Chess(game.fen());
        const m = tmp.move(uciToMoveObj(best));
        return m ? m.san : best;
      })();

      const m = game.move(uciToMoveObj(best));
      if (!m) {
        setStatus('Illegal black move â€” see log.');
        log('!! Illegal black move: ' + best);
        return;
      }

      log(`BLACK    ${san}`);
      syncBoard();

      const over = isGameOver();
      if (over.over) {
        setStatus(over.msg);
        log('GAME OVER: ' + over.msg);
        return;
      }

      // Generate next set of offers for white
      await buildOffersForWhite();
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    //  BUTTON HANDLERS
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    document.getElementById('newGame').onclick = async () => {
      if (locked) return;
      locked = true;
      game.reset();
      bankroll = STARTING_BANKROLL;
      moveNum = 0;
      elOffers.innerHTML = '';
      elLog.textContent = '';
      log('â•â•â• New game â•â•â•');
      syncBoard();
      await buildOffersForWhite();
      locked = false;
    };

    document.getElementById('refreshOffers').onclick = async () => {
      if (locked || game.turn() !== 'w') return;
      locked = true;
      log('Re-rolling offersâ€¦');
      await buildOffersForWhite();
      locked = false;
    };

    document.getElementById('resign').onclick = () => {
      if (locked) return;
      setStatus('You resigned.');
      elOffers.innerHTML = '';
      log('RESIGNED.');
    };

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    //  INIT â€” Load board, then Stockfish, then build first offers
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    async function init() {
      board = Chessboard('board', {
        position: 'start',
        orientation: 'white',
        draggable: false,
        pieceTheme: PIECE_THEME,
      });

      syncUI();
      log('Loading Stockfish (asm.js)â€¦');
      setStatus('Loading engineâ€¦');

      try {
        await engine.init();
      } catch (err) {
        setStatus('Stockfish failed to load â€” see log.');
        log('ENGINE INIT ERROR: ' + (err && err.message ? err.message : String(err)));
        log('If running locally, serve via HTTP (python3 -m http.server), not file://');
        return;
      }

      setStatus('Ready!');
      log('Stockfish ready. Let\'s play.');
      log('â•â•â• Game start â•â•â•');
      await buildOffersForWhite();
    }

    init();
  })();
  </script>
</body>
</html>
